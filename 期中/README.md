# [AI對話](https://chatgpt.com/c/69556d4a-2abc-8322-9ef4-310a0948f8f2)

使用 **牛頓法（Newton–Raphson Method）** 以數值方式求解方程式根，也就是找到使得  
\[
f(x)=0
\]
成立的 \(x\)。

---

## 目錄

- [概念總覽](#概念總覽)
- [牛頓法在做什麼](#牛頓法在做什麼)
- [數學推導](#數學推導)
- [程式在做什麼](#程式在做什麼)
- [程式碼](#程式碼)
- [如何執行](#如何執行)
- [範例：求 \(\sqrt{2}\)](#範例求-sqrt2)
- [收斂性與注意事項](#收斂性與注意事項)
- [常見問題（FAQ）](#常見問題faq)

---

## 概念總覽

很多方程式沒有漂亮的解析解，或即使有解析解也不容易用一般公式求出。例如：

- \(x^2 - 2 = 0\)（解是 \(\sqrt{2}\)）
- \(\cos x = x\)
- \(e^x = 3x\)

這時可以用**數值方法**，從一個初始猜測 \(x_0\) 出發，不斷修正，逼近真正的根。

牛頓法就是其中最常見、收斂很快的方法之一。

---

## 牛頓法在做什麼

牛頓法的直覺：

1. 你先猜一個值 \(x_n\)。
2. 在 \(x_n\) 的位置，畫出函數 \(f(x)\) 的 **切線**。
3. 用切線與 x 軸的交點當成下一次更好的猜測 \(x_{n+1}\)。
4. 重複做下去，通常會很快逼近真正的根。

也就是：用「曲線」不好解，但「直線」很好解，所以每次用切線（局部線性）去近似曲線。

---

## 數學推導

對 \(f(x)\) 在 \(x_n\) 附近做一階泰勒近似：

\[
f(x) \approx f(x_n) + f'(x_n)(x - x_n)
\]

因為根滿足 \(f(x)=0\)，所以令上式右邊等於 0：

\[
0 \approx f(x_n) + f'(x_n)(x - x_n)
\]

解出 \(x\)：

\[
x \approx x_n - \frac{f(x_n)}{f'(x_n)}
\]

因此牛頓法的更新公式是：

\[
\boxed{x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}}
\]

---

## 程式在做什麼

本程式提供一個通用函數：

- 輸入：
  - `f`：目標函數 \(f(x)\)
  - `df`：導數函數 \(f'(x)\)
  - `x0`：初始猜測值 \(x_0\)
  - `tol`：誤差容許值（停止條件）
  - `max_iter`：最多迭代次數（避免無限迴圈）

- 輸出：
  - `root`：近似根
  - `iterations`：實際迭代次數

迭代流程：

1. 計算目前誤差：`fx = f(x)`
2. 若 `abs(fx) < tol`，表示已經非常接近 0，停止並回傳結果
3. 否則套用牛頓公式更新：
   \[
   x \leftarrow x - \frac{f(x)}{f'(x)}
   \]
4. 重複直到成功或超過最大迭代次數

---

## 程式碼

將以下程式存成 `newton.py`：

```python
import math

def newton_method(f, df, x0, tol=1e-8, max_iter=100):
    """
    使用牛頓法求解 f(x) = 0

    參數:
        f (callable): 目標函數 f(x)
        df (callable): f 的導數 df(x) = f'(x)
        x0 (float): 初始猜測值
        tol (float): 收斂判斷門檻，當 |f(x)| < tol 視為收斂
        max_iter (int): 最大迭代次數

    回傳:
        (root, iterations):
            root (float): 近似根
            iterations (int): 使用迭代次數
    """
    x = x0
    for i in range(max_iter):
        fx = f(x)
        if abs(fx) < tol:
            return x, i + 1

        dfx = df(x)
        if dfx == 0:
            raise ZeroDivisionError("導數為 0，無法進行牛頓更新")

        x = x - fx / dfx

    raise ValueError("未在指定迭代次數內收斂")


if __name__ == "__main__":
    # 範例：求 sqrt(2)
    f = lambda x: x**2 - 2
    df = lambda x: 2*x

    root, iterations = newton_method(f, df, x0=1.0)
    print("近似根 =", root)
    print("迭代次數 =", iterations)
    print("驗證 f(root) =", f(root))

如何執行

在命令列執行：

python newton.py


你會看到類似輸出：

近似根接近 1.414213562...

f(root) 非常接近 0

範例：求 
2
2
	​


我們設定：

𝑓
(
𝑥
)
=
𝑥
2
−
2
⇒
𝑓
′
(
𝑥
)
=
2
𝑥
f(x)=x
2
−2⇒f
′
(x)=2x

根是 
𝑥
=
2
x=
2
	​

。

從 
𝑥
0
=
1
x
0
	​

=1 開始：

第一次更新會把你從 1 拉向 1.5

接著很快逼近 1.4142...

因為牛頓法通常是「平方收斂」，正確位數會快速增加

收斂性與注意事項
1. 為什麼牛頓法快？

當你已經接近真根 
𝑟
r 時，牛頓法通常具有 平方收斂：

誤差大約會「平方縮小」

很少迭代就能得到高精度

2. 什麼情況會失敗？

牛頓法不是保證一定成功，常見失敗原因：

初始值太差：可能跑到別的根或發散

導數為 0：更新式分母為 0 無法計算

函數不光滑或斜率太小：容易震盪或收斂慢

因此程式中加入：

max_iter 避免無限迴圈

導數為 0 時直接拋出錯誤

常見問題（FAQ）
Q1：tol 是什麼意思？

tol 是停止條件，當 |f(x)| < tol 代表 
𝑓
(
𝑥
)
f(x) 已經非常接近 0，視為找到根。

Q2：為什麼用 |f(x)| 而不是 |x_{n+1}-x_n|？

兩者都常用。本程式用 |f(x)| 表示「代回去已接近 0」。
若你想改成用步長判斷，也可以加上 abs(x_new - x) < tol。

Q3：一定要有 df(導數) 嗎？

牛頓法需要導數。若沒有導數，可用：

割線法（Secant Method）：用差分近似導數

二分法（Bisection Method）：保證收斂但較慢